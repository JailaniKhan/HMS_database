diff --git a/node_modules/@radix-ui/react-compose-refs/dist/index.js b/node_modules/@radix-ui/react-compose-refs/dist/index.js
index 5ba7a95..7bff399 100644
--- a/node_modules/@radix-ui/react-compose-refs/dist/index.js
+++ b/node_modules/@radix-ui/react-compose-refs/dist/index.js
@@ -18,10 +18,6 @@ var __copyProps = (to, from, except, desc) => {
   return to;
 };
 var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
-  // If the importer is in node compatibility mode or this is not an ESM
-  // file that has been converted to a CommonJS file using a Babel-
-  // compatible transform (i.e. "__esModule" has not been set), then set
-  // "default" to the CommonJS "module.exports" for node compatibility.
   isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
   mod
 ));
@@ -37,13 +33,30 @@ module.exports = __toCommonJS(index_exports);
 
 // packages/react/compose-refs/src/compose-refs.tsx
 var React = __toESM(require("react"));
+
+// Track ref calls to prevent infinite loops
+const refCallTimes = new WeakMap();
+
 function setRef(ref, value) {
+  // Rate limit ref calls to prevent infinite loops
+  if (ref !== null && ref !== undefined) {
+    const lastCall = refCallTimes.get(ref);
+    const now = Date.now();
+    if (lastCall && now - lastCall < 10) {
+      // Called within 10ms, skip to prevent infinite loop
+      console.log('[compose-refs-patch] Skipping rapid ref call');
+      return;
+    }
+    refCallTimes.set(ref, now);
+  }
+  
   if (typeof ref === "function") {
     return ref(value);
   } else if (ref !== null && ref !== void 0) {
     ref.current = value;
   }
 }
+
 function composeRefs(...refs) {
   return (node) => {
     let hasCleanup = false;
diff --git a/node_modules/@radix-ui/react-compose-refs/dist/index.mjs b/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
index 7dd9172..3e70b48 100644
--- a/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
+++ b/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
@@ -1,12 +1,36 @@
-// packages/react/compose-refs/src/compose-refs.tsx
 import * as React from "react";
-function setRef(ref, value) {
+
+// Check if a ref is a useState setter (common cause of infinite loops with React 19)
+function isStateSetter(ref) {
+  // State setters from useState are functions that start with 'set' and are named like 'setSomething'
+  // They typically don't have a .current property
+  if (typeof ref === 'function' && ref.name && ref.name.startsWith('set') && !ref.current) {
+    return true;
+  }
+  // Also check for common useState naming patterns
+  if (typeof ref === 'function' && ref.name && (ref.name.match(/^set[A-Z]/) || ref.name.match(/^set[A-Z][a-z]+/))) {
+    return true;
+  }
+  return false;
+}
+
+function setRef(ref, node) {
+  if (ref === null || ref === undefined) {
+    return;
+  }
+
   if (typeof ref === "function") {
-    return ref(value);
-  } else if (ref !== null && ref !== void 0) {
-    ref.current = value;
+    // Skip state setters to prevent infinite loops in React 19
+    if (isStateSetter(ref)) {
+      return;
+    }
+    ref(node);
+  }
+  else {
+    ref.current = node;
   }
 }
+
 function composeRefs(...refs) {
   return (node) => {
     let hasCleanup = false;
@@ -31,11 +55,10 @@ function composeRefs(...refs) {
     }
   };
 }
+
 function useComposedRefs(...refs) {
   return React.useCallback(composeRefs(...refs), refs);
 }
-export {
-  composeRefs,
-  useComposedRefs
-};
-//# sourceMappingURL=index.mjs.map
+
+export { composeRefs, useComposedRefs };
+// Patched to prevent infinite loops with React 19 by skipping state setter refs
